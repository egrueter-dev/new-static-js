--- 
title:      "Building Rails/ExtJS reusable components with Netzke, part 2"
created_at: 2009-03-27
kind: article
outdated: true
slug: "building_rails_extjs_reusable_components_with_netzke_part_2"
tags: [tutorials, netzke]
---
<img src='http://writelesscode.com/images/2009-03-26-intro.jpg' class="frame-right"/>
<p><em>UPDATE (2009-09-07): This tutorial is outdated with the release of netzke-basepack v0.5.0. Please, refer to <a href="http://writelesscode.com/blog/2009/09/24/building-rails-extjs-reusable-components-with-netzke-part-3/">part 3</a> which is an up-to-date and extended version of this tutorial.</em><br/> This tutorial will show you how to build a composite reusable Netzke component which consists of 2 grids (glued together by Ext’s border layout) that display data from Rails models connected by one-to-many relationship. We’ll build it in the context of the already existing <a href='http://github.com/nomadcoder/netzke-demo/tree/master'>netzke-demo</a> project (this demo runs live on <a href='http://netzke-demo.writelesscode.com/'>http://netzke-demo.writelesscode.com/</a>), so that we can spare some time reusing its models and infrastructure. The resulting widget will contain a grid with bosses and a grid with clerks. Selecting a boss will update the clerks grid with the clerks working under that boss. Adding a clerk will automatically bind him to the selected boss. You’ll learn how to create a custom Netzke widget using GridPanel and BorderLayoutPanel widgets from <a href='http://github.com/nomadcoder/netzke-basepack/tree/master'>netzke-basepack</a> (a gem that contains several pre-built, extendible Netzke widgets). If you prefer to quickly see the results rather than to follow this tutorial step-by-step (an added value of which would be to see several functional iterations of our widget), you can go straight to its live <a href='http://netzke-demo.writelesscode.com/basic_app/demo#bossesAndClerks'>demo</a>. For those that want to be led through the process of creating a Netzke widget and get a deeper understanding of how Netzke works - read on, and don’t let the volume of the post scare you too much, as you can easily skip over some details and have a coffee between the sections :)</p>

<h1 id='getting_netzkedemo_up_and_running_locally'>Getting netzke-demo up and running locally</h1>

<p>First of all, clone netzke-demo project from GitHub if you haven’t done so yet:</p>

<blockquote>
<p>git clone git://github.com/nomadcoder/netzke-demo.git &amp;&amp; cd netzke-demo</p>
</blockquote>

<p>Run the migrations:</p>

<blockquote>
<p>rake db:migrate</p>
</blockquote>

<p>Start the server (you may also consider to configure Passenger, which I would definitely recommend):</p>

<blockquote>
<p>./script/server</p>
</blockquote>

<p>Netzke-demo is up and running as you can see on <a href='http://localhost:3000/'>http://localhost:3000/</a></p>

<p>Now go to the GridPanel demo/tutorial page (which is worth studying, too), and click the “regenerate test data” link at the bottom of the page to create some random bosses and clerks. Now you should see the grids showing some data.</p>

<h1 id='creating_new_widget_first_steps'>Creating new widget, first steps</h1>

<p>We’ll call our widget OneToManyGridSetPoc (“poc” stands for “proof of concept”: it will be a simplified version of OneToManyGridSet widget that may later appear in netzke-basepack). Go to netzke-demo/lib/netzke folder and create the file</p>

<pre><code><span class='ident'>one_to_many_grid_set_poc</span><span class='punct'>.</span><span class='ident'>rb</span></code></pre>

<p>(<em>actually you’ll see that the file is already there, as the same code is being naturally used for the live demo, but you can simply remove or rename it</em>)</p>

<p>Define the class for our widget:</p>

<pre><code><span class='keyword'>module </span><span class='module'>Netzke</span>
  <span class='keyword'>class </span><span class='class'>OneToManyGridSetPoc</span> <span class='punct'>&lt;</span> <span class='constant'>BorderLayoutPanel</span>
  <span class='keyword'>end</span>
<span class='keyword'>end</span></code></pre>

<p>We inherit from BorderLayoutPanel because it can serve as aggregator for other widgets, and that’s what we need.</p>

<p>It woudn’t work just yet, because we didn’t even specify the center-region, which at least is required for Ext’s BorderLayout to work. It’s very easy to do:</p>

<pre><code><span class='keyword'>module </span><span class='module'>Netzke</span>
  <span class='keyword'>class </span><span class='class'>OneToManyGridSetPoc</span> <span class='punct'>&lt;</span> <span class='constant'>BorderLayoutPanel</span>
    <span class='keyword'>def </span><span class='method'>initial_aggregatees</span>
      <span class='punct'>{</span>
        <span class='symbol'>:center</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
          <span class='symbol'>:widget_class_name</span>    <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>GridPanel</span><span class='punct'>",</span> 
          <span class='symbol'>:data_class_name</span>      <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>Boss</span><span class='punct'>"</span>
        <span class='punct'>}</span>
      <span class='punct'>}</span>
    <span class='keyword'>end</span>
  <span class='keyword'>end</span>
<span class='keyword'>end</span></code></pre>

<p>In Netzke::Base-based classes (which BorderLayoutPanel is), we specify aggregated widgets as a hash in the method “initial_aggregatees”. BorderLayoutPanel is following a naming convention for its aggregatees: if you name them :center, :east, :west, :north, or :south, it will put them into respective regions. And what’s inside that hash? It’s the configuration for the aggregated widget: we want a GridPanel configured to use “Boss” as underlying Rails model.</p>

<p>Now our widget can be seen working… if we declare it somewhere. We can do this in a Rails controller like this:</p>

<pre><code><span class='ident'>netzke</span> <span class='symbol'>:bosses_and_clerks</span><span class='punct'>,</span> <span class='symbol'>:widget_class_name</span> <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>OneToManyGridSetPoc</span><span class='punct'>"</span></code></pre>

<p>… and then access it at the bosses_and_clerks_test action or integrate it into our views (see the details in <a href='http://github.com/nomadcoder/netzke-basepack/tree/master'>netzke-basepack readme</a>). However, let’s integrate our widget into BasicAppDemo - a Netzke::BasicApp-based widget that is already present in netzke-demo and represents our desktop-like web-app. Go to lib/netzke/basic_app_demo and add the following to the initial_late_aggregatees method (in short, late aggregatees differ from normal aggregatees by that they don’t get instantiated along with the aggregator, but can be instantiated on request later):</p>

<pre><code><span class='symbol'>:bosses_and_clerks</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
  <span class='symbol'>:widget_class_name</span>    <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>OneToManyGridSetPoc</span><span class='punct'>"</span>
<span class='punct'>}</span></code></pre>

<p>(<em>yes, it’s also there already, as well as the code to add the access to our widget from the BasicAppDemo’s menu - we won’t talk about this in this tutorial, but you may refer to <a href='http://writelesscode.com/past/2009/3/19/netzke_demo_update_actions_menus_and_authentication/'>this blog post</a></em>)</p>

<p>Now, go and see our widget in action.</p>

<p>(<em>you may do so by navigating BasicAppDemo menu</em>)</p>

<h1 id='adding_clerks_grid_to_the_east_region'>Adding clerks grid to the east region</h1>

<p>It hasn’t been much coding so far, has it? It doesn’t take much more to add the clerks grid, and you may already guess how it can be done:</p>

<pre><code><span class='keyword'>def </span><span class='method'>initial_aggregatees</span>
  <span class='punct'>{</span>
    <span class='symbol'>:center</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
      <span class='symbol'>:widget_class_name</span>    <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>GridPanel</span><span class='punct'>",</span> 
      <span class='symbol'>:data_class_name</span>      <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>Boss</span><span class='punct'>"</span>
    <span class='punct'>},</span>

    <span class='symbol'>:east</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
      <span class='symbol'>:widget_class_name</span>    <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>GridPanel</span><span class='punct'>",</span> 
      <span class='symbol'>:data_class_name</span>      <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>Clerk</span><span class='punct'>",</span> 
      <span class='symbol'>:region_config</span>        <span class='punct'>=&gt;</span> <span class='punct'>{</span>
        <span class='symbol'>:width</span>  <span class='punct'>=&gt;</span> <span class='number'>300</span><span class='punct'>,</span> 
        <span class='symbol'>:split</span>  <span class='punct'>=&gt;</span> <span class='constant'>true</span>
      <span class='punct'>}</span>
    <span class='punct'>}</span>
  <span class='punct'>}</span>
<span class='keyword'>end</span></code></pre>

<p>The only new thing here is the :region_config option for the east widget. What you put in here, is compatible with Ext.layout.BorderLayout.Region (or Ext.layout.BorderLayout.SplitRegion). For example, you can enable split bar tips like this:</p>

<pre><code><span class='symbol'>:region_config</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
  <span class='symbol'>:width</span>          <span class='punct'>=&gt;</span> <span class='number'>300</span><span class='punct'>,</span>
  <span class='symbol'>:split</span>          <span class='punct'>=&gt;</span> <span class='constant'>true</span><span class='punct'>,</span>
  <span class='symbol'>:use_split_tips</span> <span class='punct'>=&gt;</span> <span class='constant'>true</span><span class='punct'>,</span>
  <span class='symbol'>:split_tip</span>      <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>Drag to resize</span><span class='punct'>"</span>
<span class='punct'>}</span></code></pre>

<h1 id='putting_some_inplace_configuration_for_the_grids'>Putting some in-place configuration for the grids</h1>

<p>After we have seen the result, we immediately may want to tweak some things in the representation. For instance, let’s change the titles of the panels, add pagination to the grids, and specify which columns should be displayed in the grids:</p>

<pre><code><span class='keyword'>def </span><span class='method'>initial_aggregatees</span>
  <span class='punct'>{</span>
    <span class='symbol'>:center</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
      <span class='symbol'>:widget_class_name</span>    <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>GridPanel</span><span class='punct'>",</span> 
      <span class='symbol'>:data_class_name</span>      <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>Boss</span><span class='punct'>",</span>
      <span class='symbol'>:ext_config</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
        <span class='symbol'>:title</span>         <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>Bosses</span><span class='punct'>",</span>
        <span class='symbol'>:rows_per_page</span> <span class='punct'>=&gt;</span> <span class='number'>20</span>
      <span class='punct'>},</span>
      <span class='symbol'>:columns</span> <span class='punct'>=&gt;</span> <span class='punct'>%w{</span><span class='string'> id first_name last_name email salary </span><span class='punct'>}</span>
    <span class='punct'>},</span>

    <span class='symbol'>:east</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
      <span class='symbol'>:widget_class_name</span>    <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>GridPanel</span><span class='punct'>",</span> 
      <span class='symbol'>:data_class_name</span>      <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>Clerk</span><span class='punct'>",</span> 
      <span class='symbol'>:region_config</span>        <span class='punct'>=&gt;</span> <span class='punct'>{</span>
        <span class='symbol'>:width</span>  <span class='punct'>=&gt;</span> <span class='number'>300</span><span class='punct'>,</span> 
        <span class='symbol'>:split</span>  <span class='punct'>=&gt;</span> <span class='constant'>true</span>
      <span class='punct'>},</span>
      <span class='symbol'>:ext_config</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
        <span class='symbol'>:title</span>         <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>Clerks</span><span class='punct'>",</span>
        <span class='symbol'>:rows_per_page</span> <span class='punct'>=&gt;</span> <span class='number'>20</span>
      <span class='punct'>},</span>
      <span class='symbol'>:columns</span> <span class='punct'>=&gt;</span> <span class='punct'>%w{</span><span class='string'> id first_name last_name name updated </span><span class='punct'>}</span>
    <span class='punct'>}</span>
  <span class='punct'>}</span>
<span class='keyword'>end</span></code></pre>

<p>But when you reload the page, you’ll see, that while some things have changed, the columns have stayed the same. It’s because the first time you load a GridPanel, Netzke by default stores the column configuration in the database to later retrieve it from there rather then from the code.</p>

<h1 id='touching_the_topic_of_persistent_column_configuration'>Touching the topic of persistent column configuration</h1>

<p>With other words, the columns you specify in the code are simply the defaults, for the case when those can’t be retrieved from the database. What can be done about it? There are 2 ways. First, you may set the persistent_layout option for the bosses grid to false:</p>

<pre><code><span class='symbol'>:center</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
  <span class='symbol'>:widget_class_name</span>    <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>GridPanel</span><span class='punct'>",</span> 
  <span class='symbol'>:data_class_name</span>      <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>Boss</span><span class='punct'>",</span>
  <span class='symbol'>:ext_config</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
    <span class='symbol'>:title</span>         <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>Bosses</span><span class='punct'>",</span>
    <span class='symbol'>:rows_per_page</span> <span class='punct'>=&gt;</span> <span class='number'>20</span>
  <span class='punct'>},</span>
  <span class='symbol'>:columns</span>           <span class='punct'>=&gt;</span> <span class='punct'>%w{</span><span class='string'> id first_name last_name email salary </span><span class='punct'>},</span>
  <span class='symbol'>:persistent_layout</span> <span class='punct'>=&gt;</span> <span class='constant'>false</span>
<span class='punct'>},</span></code></pre>

<p>This will disable retrieving the columns from the database, and always the defaults will be used. While it can be very helpful during the development, that may not be what we would like to see now, as we loose the ability to dynamically configure the grid columns. So, a better way would be to leave the code unchanged, and go straight to the bosses GridPanel column configuration panel, by clicking the “gear”-tool button on the right-top corner. Meet the configuration widget for GridPanel! It itself is a composite widget based on Netzke::AccordionLayoutPanel. We directly see a panel that shows the column configuration, and on the bottom there’s the “Restore defaults” button, which is what we can press now to populate the database with the new defaults from the code. Do it, then press Submit and see the effect (notice how the bosses widgets gets ajaxically reloaded without any need for reloading the page, or even the host widget!)</p>

<p>One more decorative change before we continue: let’s change the title of our widget itself. I would actually prefer to remove it completely along with the title bar. It can be done by specifying default (initial) configuration for our widget:</p>

<pre><code><span class='keyword'>def </span><span class='method'>initial_config</span>
  <span class='keyword'>super</span><span class='punct'>.</span><span class='ident'>merge</span><span class='punct'>({</span>
    <span class='symbol'>:ext_config</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
      <span class='symbol'>:title</span> <span class='punct'>=&gt;</span> <span class='constant'>false</span>
    <span class='punct'>}</span>
  <span class='punct'>})</span>
<span class='keyword'>end</span></code></pre>

<h1 id='adding_interaction_between_the_2_grids'>Adding interaction between the 2 grids</h1>

<p>Now, that we have something working and good looking, notice that we haven’t written a single line of Javascript. However, my ample experience with integrating Ext and Rails <a href='http://github.com/nomadcoder/netzke/tree/master'>makes me convinced</a> that it’s something that simply cannot - and shouldn’t - be avoided. So, now it’s a good moment to add some Javascript, as we want some custom functionality for our widget: namely, we want it to react on selecting a row in bosses grid by reloading the other grid with the clerks that “belong_to” the selected boss.</p>

<p>First, we need to subscribe to the click event of the GridPanel:</p>

<pre><code><span class='keyword'>def </span><span class='method'>self.js_after_constructor</span>
  <span class='keyword'>super</span> <span class='punct'>&lt;&lt;</span> <span class='punct'>&lt;&lt;-</span><span class='constant'>JS</span><span class='string'>
    this.getCenterWidget().on("rowclick", this.onRowClick, this);
</span><span class='constant'>  JS</span>
<span class='keyword'>end</span></code></pre>

<p>In this function we put the javascript code that gets appended after the super-class’ constructor is called in our widget’s constructor (for details, see the source code for netzke-core). It’s just the right place to subscribe to events. The getCenterWidget function is provided by BorderLayoutPanel, and in this case will return the GridPanel instance (in the Javascript domain, of course).</p>

<p>Now we need to implement the handler, onRowClick:</p>

<pre><code><span class='keyword'>def </span><span class='method'>self.js_extend_properties</span>
  <span class='keyword'>super</span><span class='punct'>.</span><span class='ident'>merge</span><span class='punct'>({</span>
    <span class='symbol'>:on_row_click</span> <span class='punct'>=&gt;</span> <span class='punct'>&lt;&lt;-</span><span class='constant'>JS</span><span class='punct'>.</span><span class='ident'>l</span><span class='string'>
      function(grid, index, e){
        // get id of the selected boss
        var id = this.getCenterWidget().getStore().getAt(index).get("id");

        // load the east grid, appending to the request the id of the selected boss
        var contentGrid = this.getEastWidget();
        contentGrid.store.baseParams = {container_id:id};
        contentGrid.store.reload();
      }
</span><span class='constant'>    JS</span>
  <span class='punct'>})</span>
<span class='keyword'>end</span></code></pre>

<p>In the js_extend_properties class we specify all the public functions for our widget class in the Javascript domain. Function names get automatically translated by Netzke from Ruby style to Javascript style (this way on_row_click becomes onRowClick).</p>

<blockquote>
<p><em>The idea behind wrapping Javascript functions into Ruby hash is the extensibility: when you inherit from another Netzke::Base-based class, you can easily replace its Javascript methods with new ones. And if you worry that mixing 2 languages in one source file wouldn’t read well, turn to the technique that I describe <a href='http://writelesscode.com/past/2009/2/25/javascriptinsideruby_syntax_highlighting_with_textmate/'>here</a> - and I guarantee that your code will read very well in TextMate.</em></p>
</blockquote>

<p>In the onRowClick function we detect the id of the selected boss and append it to the parameters that get sent with the Store load request. Then the clerks grid gets reloaded. With Firebug you can easily see how it works.</p>

<blockquote>
<p><em>There’s a little caveat here related to the dynamic widget loading. If you press the gear button of the bosses grid, and then click Submit (thus commanding the bosses GridPanel to reload), you’ll discover that the clerks grid stopped reacting on the clicks at the bosses. This happens due to that we subscribed to the rowclick event of the GridPanel that is not there anymore. To fix that, slightly modify the way how we do that (we want to subscribe to rowclick every time that a new GridPanel is loaded into the central region):</em></p>
</blockquote>

<pre><code><span class='keyword'>def </span><span class='method'>self.js_after_constructor</span>
  <span class='keyword'>super</span> <span class='punct'>&lt;&lt;</span> <span class='punct'>&lt;&lt;-</span><span class='constant'>JS</span><span class='string'>
    var setCentralWidgetEvents = function(){
      this.getCenterWidget().on("rowclick", this.onRowClick, this);
    };
    this.getCenterWidget().ownerCt.on("add", setCentralWidgetEvents, this);
    setCentralWidgetEvents.call(this);
</span><span class='constant'>  JS</span>
<span class='keyword'>end</span></code></pre>

<p>While the clerks grid now gets reloaded on each click in the bosses grid, there’s still no filtering of clerks taking place. To fix that, let’s do some coding for the server side of our widget.</p>

<h1 id='server_side_filtering_of_clerks_by_specified_boss_id'>Server side filtering of clerks by specified boss ID</h1>

<p>When a request comes for clerks data, how does the clerks instance of the GridPanel on the server know that the request is directed exactly to it, and not, for example, to bosses grid? This information is encoded in the name of the Rails’ action that handles the AJAX call. In our specific case the action looks like this:</p>

<pre><code><span class='ident'>basic_app_demo__bosses_and_clerks__east__get_data</span></code></pre>

<p>Basically, it’s the “address” of the widget plus the name of its (interface) method that the widget should execute. It goes like this: when the Netzke-enabled controller receives this request, it instantiates basic_app_demo widget and sends it the following method along with the parameters:</p>

<pre><code><span class='ident'>bosses_and_clerks__east__get_data</span></code></pre>

<p>In its turn, basic_app_demo widget (our ‘application’) instantiates bosses_and_clerks widget (which belongs in its late aggregatees), and sends it the rest:</p>

<pre><code><span class='ident'>east__get_data</span></code></pre>

<p>I hope you get the idea, and there’s only one more thing to mention here: this dispatching is done by means of the wonderful Ruby’s method_missing method. It means, that when bosses_and_clerks instance “sees” that it has no method called “east__get_data”, it knows that it should instantiate its aggregatee named “east” and send to it “the rest” of the method. Straight from here comes the ability of a Netzke widget to interact with <em>any</em> communication going down its internal hierarchy.</p>

<p>I hope you see how we are going to use it in order to override the default behavior of clerks get_data method right from our widget. Here’s how:</p>

<pre><code><span class='keyword'>def </span><span class='method'>east__get_data</span><span class='punct'>(</span><span class='ident'>params</span><span class='punct'>)</span>
  <span class='comment'># extract Ext filters from params (we want them keep on working)</span>
  <span class='ident'>filters</span> <span class='punct'>=</span> <span class='ident'>params</span><span class='punct'>[</span><span class='symbol'>:filter</span><span class='punct'>]</span> <span class='punct'>||=</span> <span class='punct'>{}</span>

  <span class='comment'># calculate the foreign key based on container class</span>
  <span class='ident'>foreign_key</span> <span class='punct'>=</span> <span class='ident'>aggregatees</span><span class='punct'>[</span><span class='symbol'>:center</span><span class='punct'>][</span><span class='symbol'>:data_class_name</span><span class='punct'>].</span>
                <span class='ident'>constantize</span><span class='punct'>.</span><span class='ident'>table_name</span><span class='punct'>.</span><span class='ident'>singularize</span> <span class='punct'>+</span> <span class='punct'>"</span><span class='string'>_id</span><span class='punct'>"</span>

  <span class='comment'># add the foreign key filter to the filters</span>
  <span class='ident'>filters</span><span class='punct'>.</span><span class='ident'>merge!</span><span class='punct'>({</span><span class='symbol'>:our_fkey_filter</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
    <span class='symbol'>:data</span>  <span class='punct'>=&gt;</span> <span class='punct'>{</span><span class='symbol'>:value</span> <span class='punct'>=&gt;</span> <span class='ident'>params</span><span class='punct'>[</span><span class='symbol'>:container_id</span><span class='punct'>],</span> <span class='symbol'>:type</span> <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>integer</span><span class='punct'>"},</span>
    <span class='symbol'>:field</span> <span class='punct'>=&gt;</span> <span class='ident'>foreign_key</span><span class='punct'>}</span>
  <span class='punct'>})</span>

  <span class='comment'># call the original get_data method, but with updated filters</span>
  <span class='ident'>method_missing</span><span class='punct'>(</span><span class='symbol'>:east__get_data</span><span class='punct'>,</span> <span class='ident'>params</span><span class='punct'>.</span><span class='ident'>merge</span><span class='punct'>(</span><span class='symbol'>:filter</span> <span class='punct'>=&gt;</span> <span class='ident'>filters</span><span class='punct'>))</span>
<span class='keyword'>end</span></code></pre>

<p>By this, we can process the call to the east__get_data method, where before it was done by method_missing. It will let us interact with the get_data request coming to clerks grid, and extend the filters specified in the parameters with the boss_id set to the id of the currently selected boss. At the end we call the method_missing ourselves, but pass it the tweaked parameters. Go back to the browser and see how this works.</p>

<p>Similar way we implement east__post_data method:</p>

<pre><code><span class='keyword'>def </span><span class='method'>east__post_data</span><span class='punct'>(</span><span class='ident'>params</span><span class='punct'>)</span>
  <span class='ident'>container_id</span> <span class='punct'>=</span> <span class='ident'>params</span><span class='punct'>[</span><span class='symbol'>:base_params</span><span class='punct'>]</span> <span class='punct'>&amp;&amp;</span> 
    <span class='constant'>ActiveSupport</span><span class='punct'>::</span><span class='constant'>JSON</span><span class='punct'>.</span><span class='ident'>decode</span><span class='punct'>(</span><span class='ident'>params</span><span class='punct'>[</span><span class='symbol'>:base_params</span><span class='punct'>])["</span><span class='string'>container_id</span><span class='punct'>"]</span>

  <span class='ident'>foreign_key</span> <span class='punct'>=</span> <span class='ident'>aggregatees</span><span class='punct'>[</span><span class='symbol'>:center</span><span class='punct'>][</span><span class='symbol'>:data_class_name</span><span class='punct'>].</span>
                <span class='ident'>constantize</span><span class='punct'>.</span><span class='ident'>table_name</span><span class='punct'>.</span><span class='ident'>singularize</span> <span class='punct'>+</span> <span class='punct'>"</span><span class='string'>_id</span><span class='punct'>"</span>

  <span class='comment'># for new records, merge foreign key in</span>
  <span class='ident'>new_records</span> <span class='punct'>=</span> <span class='ident'>params</span><span class='punct'>[</span><span class='symbol'>:created_records</span><span class='punct'>]</span> <span class='punct'>&amp;&amp;</span> 
    <span class='constant'>ActiveSupport</span><span class='punct'>::</span><span class='constant'>JSON</span><span class='punct'>.</span><span class='ident'>decode</span><span class='punct'>(</span><span class='ident'>params</span><span class='punct'>.</span><span class='ident'>delete</span><span class='punct'>(</span><span class='symbol'>:created_records</span><span class='punct'>))</span>
  <span class='keyword'>if</span> <span class='ident'>new_records</span>
    <span class='keyword'>for</span> <span class='ident'>r</span> <span class='keyword'>in</span> <span class='ident'>new_records</span>
      <span class='ident'>r</span><span class='punct'>.</span><span class='ident'>merge!</span><span class='punct'>(</span><span class='ident'>foreign_key</span> <span class='punct'>=&gt;</span> <span class='ident'>container_id</span><span class='punct'>)</span>
    <span class='keyword'>end</span>
  <span class='keyword'>end</span>

  <span class='comment'># call the original get_data method, but with corrected params</span>
  <span class='ident'>method_missing</span><span class='punct'>(</span><span class='symbol'>:east__post_data</span><span class='punct'>,</span> <span class='ident'>params</span><span class='punct'>.</span><span class='ident'>merge</span><span class='punct'>(</span><span class='symbol'>:created_records</span> <span class='punct'>=&gt;</span> <span class='ident'>new_records</span><span class='punct'>.</span><span class='ident'>to_json</span><span class='punct'>))</span>
<span class='keyword'>end</span></code></pre>

<p>Now when we create a clerk, it will be assigned to the currently selected boss (if any).</p>

<h1 id='making_it_reusable_or_generic'>Making it reusable, or generic</h1>

<p>For now our widget is not generic, as it has the bosses and clerks model names hard-coded along with some other configuration for the inner widgets. It would be nice to be able to configure OneToManyGridSetPoc widget like this (the simplest way):</p>

<pre><code><span class='ident'>netzke</span> <span class='symbol'>:bosses_and_clerks</span><span class='punct'>,</span> 
  <span class='symbol'>:widget_class_name</span>    <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>OneToManyGridSetPoc</span><span class='punct'>",</span>
  <span class='symbol'>:container_class_name</span> <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>Boss</span><span class='punct'>",</span>
  <span class='symbol'>:element_class_name</span>   <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>Clerk</span><span class='punct'>"</span></code></pre>

<p>All we need to do is to replace the hard-coded values with corresponding config hash values:</p>

<pre><code><span class='keyword'>def </span><span class='method'>initial_aggregatees</span>
  <span class='punct'>{</span>
    <span class='symbol'>:center</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
      <span class='symbol'>:widget_class_name</span>    <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>GridPanel</span><span class='punct'>",</span> 
      <span class='symbol'>:data_class_name</span>      <span class='punct'>=&gt;</span> <span class='ident'>config</span><span class='punct'>[</span><span class='symbol'>:container_class_name</span><span class='punct'>],</span>
      <span class='symbol'>:ext_config</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
        <span class='symbol'>:title</span>         <span class='punct'>=&gt;</span> <span class='ident'>config</span><span class='punct'>[</span><span class='symbol'>:container_class_name</span><span class='punct'>].</span><span class='ident'>pluralize</span><span class='punct'>,</span>
        <span class='symbol'>:rows_per_page</span> <span class='punct'>=&gt;</span> <span class='number'>20</span>
      <span class='punct'>}</span>
    <span class='punct'>},</span>

    <span class='symbol'>:east</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
      <span class='symbol'>:widget_class_name</span>    <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>GridPanel</span><span class='punct'>",</span> 
      <span class='symbol'>:data_class_name</span>      <span class='punct'>=&gt;</span> <span class='ident'>config</span><span class='punct'>[</span><span class='symbol'>:element_class_name</span><span class='punct'>],</span>
      <span class='symbol'>:region_config</span>        <span class='punct'>=&gt;</span> <span class='punct'>{</span>
        <span class='symbol'>:width</span>  <span class='punct'>=&gt;</span> <span class='number'>300</span><span class='punct'>,</span> 
        <span class='symbol'>:split</span>  <span class='punct'>=&gt;</span> <span class='constant'>true</span>
      <span class='punct'>},</span>
      <span class='symbol'>:ext_config</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
        <span class='symbol'>:title</span>         <span class='punct'>=&gt;</span> <span class='ident'>config</span><span class='punct'>[</span><span class='symbol'>:element_class_name</span><span class='punct'>].</span><span class='ident'>pluralize</span><span class='punct'>,</span>
        <span class='symbol'>:rows_per_page</span> <span class='punct'>=&gt;</span> <span class='number'>20</span>
      <span class='punct'>}</span>
    <span class='punct'>}</span>
  <span class='punct'>}</span>
<span class='keyword'>end</span></code></pre>

<p>And if we want even more configuration freedom? Say, something like this:</p>

<pre><code><span class='ident'>netzke</span> <span class='symbol'>:bosses_and_clerks</span><span class='punct'>,</span> 
  <span class='symbol'>:widget_class_name</span>    <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>OneToManyGridSetPoc</span><span class='punct'>",</span>
  <span class='symbol'>:container_config</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
    <span class='symbol'>:data_class_name</span> <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>Boss</span><span class='punct'>",</span>
    <span class='symbol'>:ext_config</span>      <span class='punct'>=&gt;</span> <span class='punct'>{</span>
      <span class='symbol'>:rows_per_page</span> <span class='punct'>=&gt;</span> <span class='number'>10</span>
    <span class='punct'>}</span>
  <span class='punct'>},</span>
  <span class='symbol'>:element_config</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
    <span class='symbol'>:data_class_name</span> <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>Clerk</span><span class='punct'>",</span>
    <span class='symbol'>:columns</span>         <span class='punct'>=&gt;</span> <span class='punct'>[</span><span class='symbol'>:id</span><span class='punct'>,</span> <span class='symbol'>:name</span><span class='punct'>,</span> <span class='symbol'>:salary</span><span class='punct'>,</span> <span class='symbol'>:updated</span><span class='punct'>],</span>
    <span class='symbol'>:region_config</span>   <span class='punct'>=&gt;</span> <span class='punct'>{</span>
      <span class='symbol'>:width</span> <span class='punct'>=&gt;</span> <span class='number'>500</span>
    <span class='punct'>}</span>
  <span class='punct'>}</span></code></pre>

<p>It’s also easy: just recursively merge the region widgets configuration with the corresponding config:</p>

<pre><code><span class='keyword'>def </span><span class='method'>initial_aggregatees</span>
  <span class='punct'>{</span>
    <span class='symbol'>:center</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
      <span class='symbol'>:widget_class_name</span>    <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>GridPanel</span><span class='punct'>",</span> 
      <span class='symbol'>:data_class_name</span>      <span class='punct'>=&gt;</span> <span class='ident'>config</span><span class='punct'>[</span><span class='symbol'>:container_class_name</span><span class='punct'>],</span>
      <span class='symbol'>:ext_config</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
        <span class='symbol'>:rows_per_page</span> <span class='punct'>=&gt;</span> <span class='number'>20</span>
      <span class='punct'>}</span>
    <span class='punct'>}.</span><span class='ident'>recursive_merge</span><span class='punct'>(</span><span class='ident'>config</span><span class='punct'>[</span><span class='symbol'>:container_config</span><span class='punct'>]</span> <span class='punct'>||</span> <span class='punct'>{}),</span>

    <span class='symbol'>:east</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
      <span class='symbol'>:widget_class_name</span>    <span class='punct'>=&gt;</span> <span class='punct'>"</span><span class='string'>GridPanel</span><span class='punct'>",</span> 
      <span class='symbol'>:data_class_name</span>      <span class='punct'>=&gt;</span> <span class='ident'>config</span><span class='punct'>[</span><span class='symbol'>:element_class_name</span><span class='punct'>],</span>
      <span class='symbol'>:region_config</span>        <span class='punct'>=&gt;</span> <span class='punct'>{</span>
        <span class='symbol'>:width</span>  <span class='punct'>=&gt;</span> <span class='number'>300</span><span class='punct'>,</span> 
        <span class='symbol'>:split</span>  <span class='punct'>=&gt;</span> <span class='constant'>true</span>
      <span class='punct'>},</span>
      <span class='symbol'>:ext_config</span> <span class='punct'>=&gt;</span> <span class='punct'>{</span>
        <span class='symbol'>:rows_per_page</span> <span class='punct'>=&gt;</span> <span class='number'>20</span>
      <span class='punct'>}</span>
    <span class='punct'>}.</span><span class='ident'>recursive_merge</span><span class='punct'>(</span><span class='ident'>config</span><span class='punct'>[</span><span class='symbol'>:element_config</span><span class='punct'>]</span> <span class='punct'>||</span> <span class='punct'>{})</span>
  <span class='punct'>}</span>
<span class='keyword'>end</span></code></pre>

<h1 id='wrapping_it_up'>Wrapping it up</h1>

<p><img src='http://writelesscode.com/images/2009-03-26.jpg' alt='OneToManyGridSetPoc'/></p>

<p>Well, I hope you managed to follow it all all the way trough, because if you did, you now have a pretty thorough understanding of design decisions lying behind Netzke. The topics we touched here include:</p>

<ul>
<li>Combining multiple pre-built widgets into a composite widget with the help of Netzke::BorderLayoutPanel</li>

<li>Setting up interaction between sub-widgets</li>

<li>Persistent dynamic configuration of a widget</li>

<li>Overriding default behavior of a sub-widget</li>

<li>Making a widget generic by introducing new configuration options</li>
</ul>

<p>Don’t hesitate to comment both on technical and non-technical (e.g. readability) aspects of this post.</p>